// O(n) time and space
class Solution {
public:
    int nthUglyNumber(int n) {
        vector<int> ret {1};
        int x = 0, y = 0, z = 0;
        
        while((int)ret.size() < n) {
            ret.push_back(min({2 * ret[x], 3 * ret[y], 5 * ret[z]}));
            
            if(ret.back() == 2 * ret[x])   x++;
            if(ret.back() == 3 * ret[y])   y++;
            if(ret.back() == 5 * ret[z])   z++;
        }
        return ret.back();
    }
};

/*

The key is to realize that every ugly number will be some previous ugly number multiplied by either 2 or 3 or 5 only.

Ex: 1 2 3 4 5 6 8 9 10 12 15 .. 
Now the next ugly number must be x * 2 or y * 3 or z * 5, where x, y, z is an existing number. We can find these x, y, z by apparently traversing the sequence generated by far from 1 ... 15,
until we find such x, y, z that x * 2, y * 3, z * 5 is just bigger than 15. In this case x = 8, y = 6, z = 4. Then we compare x * 2, y * 3, z * 5 so we know next number will be x * 2 = 8 * 2 = 16. Now we have 1,2,3,4,....,15,16.

To avoid having to do it over and over again we can keep maintaining 3 numbers x, y, z (to point ot indicies or previous answers stored in vector)

*/
